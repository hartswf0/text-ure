<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TEXT-URE v16 ‚Äî Semantic Raycaster</title>
    <style>
        :root {
            --bg: #050505;
            --ui-text: #00ff41; 
            --ui-accent: #00ffff; 
            --ui-dim: rgba(0, 255, 65, 0.2);
            --font-mono: 'Courier New', Courier, monospace;
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; }

        body {
            background-color: var(--bg);
            color: var(--ui-text);
            font-family: var(--font-mono);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #game-container { position: relative; flex: 1; width: 100%; height: 100%; background: #000; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* MODES */
        body.cinematic .hud, body.cinematic .scanner, body.cinematic .touch-controls, body.cinematic .crosshair, body.cinematic .beam-guide, body.cinematic .minimap { display: none !important; }
        body.hide-scanner .scanner { display: none !important; }

        /* UI ELEMENTS */
        .hud {
            position: absolute; top: 0; left: 0; width: 100%; padding: 1rem;
            pointer-events: none; display: flex; justify-content: space-between; align-items: flex-start; z-index: 10;
        }
        .hud-left { background: rgba(0,0,0,0.6); padding: 8px; border-left: 2px solid var(--ui-text); backdrop-filter: blur(2px); pointer-events: auto; }
        .hud-left h1 { font-size: 0.8rem; margin: 0; color: #fff; letter-spacing: 1px; }
        .stats { font-size: 0.6rem; color: var(--ui-text); opacity: 0.8; margin-top: 4px; }

        .source-selector { pointer-events: auto; display: flex; flex-direction: column; gap: 5px; align-items: flex-end; }
        .btn-source {
            background: rgba(0,0,0,0.8); border: 1px solid #444; color: #888;
            padding: 6px 12px; font-family: var(--font-mono); font-size: 0.65rem;
            cursor: pointer; text-transform: uppercase; width: 90px; text-align: right; transition: all 0.2s;
        }
        .btn-source:hover { border-color: #fff; color: #fff; }
        .btn-source.active { border-color: var(--ui-text); color: var(--ui-text); background: rgba(0, 255, 65, 0.1); }
        .config-btn { margin-top: 10px; border-color: #fff; color: #fff; }

        /* MINIMAP */
        .minimap {
            position: absolute; top: 80px; left: 1rem;
            border: 1px solid var(--ui-dim); background: rgba(0,0,0,0.8);
            pointer-events: none; z-index: 9;
            width: 100px; height: 100px;
            display: flex; align-items: center; justify-content: center;
        }
        #minimap-canvas { width: 100%; height: 100%; display: block; }

        /* SCANNER */
        .scanner {
            position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%);
            width: 85%; max-width: 500px; text-align: center; pointer-events: none; z-index: 15;
            transition: opacity 0.3s;
            display: flex; flex-direction: column; gap: 5px;
        }
        .scanner-header { display: flex; justify-content: center; align-items: center; gap: 10px; pointer-events: auto; }
        .scanner-label { font-size: 0.5rem; background: var(--ui-text); color: #000; padding: 2px 6px; font-weight: bold; letter-spacing: 1px; }
        .tts-btn { 
            font-size: 0.5rem; background: transparent; color: var(--ui-text); border: 1px solid var(--ui-text); 
            padding: 2px 6px; cursor: pointer; font-weight: bold; font-family: var(--font-mono); 
        }
        .tts-btn:hover { background: var(--ui-text); color: #000; }
        .scanner-text {
            background: rgba(5,5,5,0.9); padding: 12px; border: 1px solid var(--ui-text);
            color: #fff; font-size: 0.95rem; line-height: 1.4; 
            height: 4.5em; overflow: hidden;
            white-space: pre-wrap; box-shadow: 0 0 20px rgba(0,0,0,0.8);
            text-shadow: 0 0 5px rgba(255,255,255,0.2);
            backdrop-filter: blur(4px);
            display: flex; align-items: center; justify-content: center;
        }

        /* IMAGE GENERATION MODAL */
        #img-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200; flex-direction: column;
            align-items: center; justify-content: center; padding: 20px;
            pointer-events: auto;
        }
        #img-modal.active { display: flex; }
        
        #gen-image-container {
            position: relative;
            width: 100%; max-width: 600px; aspect-ratio: 16/9;
            border: 1px solid var(--ui-text);
            box-shadow: 0 0 30px var(--ui-dim);
            margin-bottom: 10px;
            background: #000;
            display: flex; justify-content: center; align-items: center;
            overflow: hidden;
        }
        
        #img-screenshot { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: cover; z-index: 1; opacity: 1; transition: opacity 0.5s; }
        #img-depth { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: cover; z-index: 2; opacity: 0; transition: opacity 0.5s; mix-blend-mode: normal; }
        #gen-image { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: cover; z-index: 3; opacity: 0; transition: opacity 0.5s; mix-blend-mode: normal; } 
        #effect-canvas { position: absolute; top:0; left:0; width: 100%; height: 100%; pointer-events: none; z-index: 4; }

        .modal-controls { width: 100%; max-width: 600px; display: flex; flex-direction: column; gap: 10px; }
        
        /* MIXER UI */
        .mixer-container {
            display: flex; flex-direction: column; gap: 8px; width: 100%;
            background: rgba(255,255,255,0.03); padding: 12px; border: 1px solid #333;
        }
        .mixer-row {
            display: flex; align-items: center; gap: 15px; font-size: 0.7rem; color: var(--ui-text);
        }
        .mixer-row label { width: 60px; text-align: right; font-weight: bold; letter-spacing: 1px; }
        .mixer-row input { flex: 1; }

        .tui-select {
            background: #000; color: var(--ui-text); border: 1px solid var(--ui-text);
            font-family: var(--font-mono); font-size: 0.7rem; padding: 2px 5px; outline: none; text-transform: uppercase;
            width: 100px;
        }

        .modal-caption {
            color: #fff; font-family: var(--font-mono); 
            text-align: center; font-size: 0.8rem; opacity: 0.8;
            min-height: 1.5em;
        }

        /* TUI OVERLAY */
        #tui-overlay {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 450px; background: rgba(10, 15, 10, 0.98); border: 1px solid var(--ui-text);
            box-shadow: 0 0 50px #000; padding: 20px; z-index: 100; pointer-events: auto; max-height: 80vh; overflow-y: auto;
        }
        #tui-overlay.active { display: block; }
        .tui-header { border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; }
        .tui-section { margin-bottom: 20px; }
        .tui-label { font-size: 0.6rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px; }
        
        .buffer-box { 
            width: 100%; height: 100px; background: #000; border: 1px solid #333; 
            padding: 8px; font-size: 0.7rem; overflow-y: auto; color: #aaa; margin-bottom: 5px; user-select: text; 
        }
        
        .tui-btn { 
            background: transparent; border: 1px solid var(--ui-text); color: var(--ui-text); 
            padding: 8px 12px; font-family: var(--font-mono); font-size: 0.7rem; cursor: pointer; margin-right: 5px; margin-bottom: 5px;
            display: inline-flex; align-items: center; justify-content: center; gap: 6px;
        }
        .tui-btn:hover { background: var(--ui-text); color: #000; }
        .tui-btn.secondary { border-color: #666; color: #888; }
        .tui-btn.secondary:hover { background: #666; color: #fff; }
        .tui-btn.accent { border-color: var(--ui-accent); color: var(--ui-accent); }
        .tui-btn.accent:hover { background: var(--ui-accent); color: #000; }

        /* ICON BUTTONS */
        .icon-group { flex: 1; display: flex; flex-direction: column; gap: 5px; }
        .group-label { font-size: 0.5rem; color: #666; text-align: center; letter-spacing: 1px; margin-bottom: 2px; }
        .icon-btn-row { display: flex; gap: 5px; }
        .tui-btn.icon-btn { flex: 1; padding: 10px 0; margin: 0; }
        .tui-btn.icon-btn svg { width: 16px; height: 16px; }

        input[type=range] { width: 100%; background: transparent; -webkit-appearance: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 12px; width: 12px; background: var(--ui-text); margin-top: -4px; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #333; }

        /* TOUCH CONTROLS */
        .touch-controls {
            position: absolute; bottom: 20px; left: 0; width: 100%; height: 140px;
            pointer-events: none; display: flex; justify-content: space-between; padding: 0 30px; z-index: 20;
        }
        .control-zone {
            width: 100px; height: 100px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%; pointer-events: auto; display: flex; justify-content: center; align-items: center;
            touch-action: none; backdrop-filter: blur(2px); transition: background 0.2s;
        }
        .control-zone:active { background: rgba(255,255,255,0.1); border-color: var(--ui-text); }
        .d-pad-label { font-size: 0.5rem; opacity: 0.6; color: #fff; letter-spacing: 1px; }

        /* MISC */
        .crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%);
            border: 1px solid rgba(255,255,255,0.3); border-radius: 50%; pointer-events: none; z-index: 12;
        }
        .beam-guide { position: absolute; top: 0; bottom: 0; width: 1px; background: var(--ui-text); opacity: 0.05; pointer-events: none; transition: left 0.1s; }
        .vignette { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 60%, #000 130%); pointer-events: none; z-index: 5; }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; justify-content: center; align-items: center; z-index: 200; transition: opacity 0.5s; }
        #depth-canvas { display: none; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="raycaster"></canvas>
        <canvas id="depth-canvas"></canvas>
        <div class="vignette"></div>
        <div class="crosshair"></div>
        <div class="beam-guide" id="guide-left"></div>
        <div class="beam-guide" id="guide-right"></div>

        <div class="hud">
            <div class="hud-left">
                <h1>Semantic Engine v16</h1>
                <div class="stats">POS: <span id="debug-pos">0,0</span></div>
            </div>
            <div class="source-selector">
                <button class="btn-source active" onclick="loadWorld('ILIAD')">Iliad</button>
                <button class="btn-source" onclick="loadWorld('INFERNO')">Inferno</button>
                <button class="btn-source" onclick="loadWorld('NEURO')">Neuro</button>
                <button class="btn-source config-btn" onclick="toggleTUI()">SYSTEM</button>
            </div>
        </div>

        <div class="minimap">
            <canvas id="minimap-canvas" width="100" height="100"></canvas>
        </div>

        <div class="scanner">
            <div class="scanner-text" id="scanner-output">...</div>
            <div class="scanner-header">
                <div class="scanner-label">SAMPLER</div>
                <button class="tts-btn" onclick="speakBuffer()">üîä SPEAK</button>
                <button class="tts-btn" onclick="generateFromBuffer()">üëÅÔ∏è VISION</button>
            </div>
        </div>

        <!-- VISION MODAL -->
        <div id="img-modal">
            <div id="gen-image-container">
                <img id="img-screenshot" src="" alt="Screenshot">
                <img id="img-depth" src="" alt="Depth Map">
                <img id="gen-image" src="" alt="Neural Vision">
                <canvas id="effect-canvas"></canvas>
            </div>
            
            <div class="modal-controls">
                <div class="modal-caption" id="img-caption">Waiting for signal...</div>
                
                <!-- SPECTRAL MIXER -->
                <div class="mixer-container" id="mixer-ui" style="display:none;">
                    <div class="mixer-row" style="justify-content: flex-end;">
                        <label style="width: auto; margin-right: 10px;">BLEND MODE</label>
                        <select id="blend-mode-select" class="tui-select" onchange="updateBlendMode(this.value)">
                            <option value="normal">NORMAL</option>
                            <option value="screen">SCREEN</option>
                            <option value="multiply">MULTIPLY</option>
                            <option value="overlay">OVERLAY</option>
                            <option value="difference">DIFFERENCE</option>
                        </select>
                    </div>
                    <div class="mixer-row">
                        <label>VISION</label>
                        <input type="range" min="0" max="100" value="0" id="slider-vision" oninput="setOpacity('gen-image', this.value)">
                    </div>
                    <div class="mixer-row">
                        <label>DEPTH</label>
                        <input type="range" min="0" max="100" value="0" id="slider-depth" oninput="setOpacity('img-depth', this.value)">
                    </div>
                </div>

                <div id="action-buttons" style="display:none; width: 100%; gap:10px; margin-top:5px;">
                    <div style="width:100%; display:flex; justify-content:center; margin-bottom:5px;">
                        <button class="tui-btn accent" onclick="downloadComposite()" title="Download All Three" style="width:100%;">
                            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:5px;"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                            DOWNLOAD TRIAD
                        </button>
                    </div>
                    
                    <!-- Reality Controls -->
                    <div class="icon-group">
                        <div class="group-label">REALITY</div>
                        <div class="icon-btn-row">
                            <button class="tui-btn icon-btn" onclick="downloadImage('img-screenshot', 'snapshot')" title="Download Reality">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                            </button>
                            <button class="tui-btn icon-btn secondary" onclick="copyImage('img-screenshot')" title="Copy Reality">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Vision Controls -->
                    <div class="icon-group">
                        <div class="group-label">VISION</div>
                        <div class="icon-btn-row">
                            <button class="tui-btn icon-btn" onclick="downloadImage('gen-image', 'vision')" title="Download Vision">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                            </button>
                            <button class="tui-btn icon-btn secondary" onclick="copyImage('gen-image')" title="Copy Vision">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                            </button>
                        </div>
                    </div>

                    <!-- Depth Controls -->
                    <div class="icon-group">
                        <div class="group-label">DEPTH</div>
                        <div class="icon-btn-row">
                            <button class="tui-btn icon-btn" onclick="downloadImage('img-depth', 'depthmap')" title="Download Depth">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                            </button>
                            <button class="tui-btn icon-btn secondary" onclick="copyImage('img-depth')" title="Copy Depth">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                            </button>
                        </div>
                    </div>
                </div>

                <div style="display:flex; justify-content:center; gap:10px; margin-top:5px;">
                    <button class="tui-btn" style="width:100%" onclick="closeImgModal()">CLOSE SIGNAL</button>
                </div>
            </div>
        </div>

        <!-- TUI OVERLAY -->
        <div id="tui-overlay">
            <div class="tui-header"><span>SYSTEM CONFIG</span><span style="cursor:pointer" onclick="toggleTUI()">[X]</span></div>
            
            <div class="tui-section">
                <label class="tui-label">Sampler Beam Width: <span id="val-beam">100</span>px</label>
                <input type="range" min="20" max="300" value="100" oninput="updateBeam(this.value)">
            </div>

            <div class="tui-section">
                <label class="tui-label">Sample Buffer</label>
                <div class="buffer-box" id="buffer-history">// Buffer ready.</div>
                <button class="tui-btn" onclick="copyBuffer()">Copy All</button>
                <button class="tui-btn secondary" onclick="clearBuffer()">Clear</button>
                <button class="tui-btn accent" onclick="exportMemories()">DOWNLOAD DATASET</button>
            </div>

            <div class="tui-section">
                <label class="tui-label">Modes</label>
                <button class="tui-btn" onclick="toggleScannerUI()">Toggle Scanner Text</button>
                <button class="tui-btn" onclick="toggleCinematic()">Hide UI (H)</button>
            </div>
        </div>

        <div class="touch-controls">
            <div class="control-zone" id="stick-move"><div class="d-pad-label">MOVE</div></div>
            <div class="control-zone" id="stick-look"><div class="d-pad-label">LOOK</div></div>
        </div>

        <div id="loader"><div style="animation: pulse 1s infinite; font-size:0.8rem; color:#00ff41; font-family:'Courier New';">INITIALIZING VOID...</div></div>
    </div>

    <script>
        // --- CONFIG & STATE ---
        const CONFIG = {
            fov: 0.66,
            res: 1, 
            speed: { move: 4.0, rot: 2.0 },
            mapWidth: 24, mapHeight: 24,
            charResolution: 64, charsPerStrip: 16, strandsPerBlock: 4, 
            scannerWidth: 100,
            minimapCell: 4
        };

        const WORLDS = {
            ILIAD: {
                id: 'ILIAD',
                stylePrompt: "Ancient Greek oil painting, first person view, dramatic lighting, bronze and gold colors",
                palette: { text: '#FFD700', bg: '#080600', floorStart: '#1a1500', floorEnd: '#000000', map: '#D4AF37' },
                text: "SING GODDESS THE WRATH OF ACHILLES PELEUS SON THE DESTRUCTIVE WRATH WHICH BROUGHT COUNTLESS WOES UPON THE ACHAEANS AND SENT FORTH TO HADES MANY VALIANT SOULS OF HEROES AND MADE THEM THEMSELVES SPOIL FOR DOGS AND EVERY BIRD THUS THE PLAN OF ZEUS CAME TO FULFILLMENT FROM THE TIME WHEN FIRST THEY PARTED IN STRIFE ATREUS SON KING OF MEN AND BRILLIANT ACHILLES THERE SHONE THE IMAGE OF THE MASTER MIND THERE EARTH THERE HEAVEN THERE OCEAN HE DESIGNED THE UNWEARIED SUN THE MOON COMPLETELY ROUND THE STARRY LIGHTS THAT HEAVENS HIGH CONVEX CROWNED TWO CITIES RADIANT ON THE SHIELD APPEAR THE IMAGE ONE OF PEACE AND ONE OF WAR",
                mapType: "RINGS"
            },
            INFERNO: {
                id: 'INFERNO',
                stylePrompt: "Gustave Dore style etching, dark gloomy hellscape, first person perspective, atmospheric fog",
                palette: { text: '#ff3333', bg: '#080000', floorStart: '#200000', floorEnd: '#000000', map: '#ff3333' },
                text: "MIDWAY UPON THE JOURNEY OF OUR LIFE I FOUND MYSELF WITHIN A FOREST DARK FOR THE STRAIGHTFORWARD PATHWAY HAD BEEN LOST AH ME HOW HARD A THING IT IS TO SAY WHAT WAS THIS FOREST SAVAGE ROUGH AND STERN WHICH IN THE VERY THOUGHT RENEWS THE FEAR SO BITTER IS IT DEATH IS LITTLE MORE BUT OF THE GOOD TO TREAT WHICH THERE I FOUND SPEAK WILL I OF THE OTHER THINGS I SAW I CANNOT WELL REPEAT HOW THERE I ENTERED SO FULL WAS I OF SLUMBER AT THE MOMENT IN WHICH I HAD ABANDONED THE TRUE WAY BUT AFTER I HAD REACHED A MOUNTAIN FOOT AT THAT POINT WHERE THE VALLEY TERMINATED WHICH HAD WITH CONSTERNATION PIERCED MY HEART UPWARD I LOOKED AND I BEHELD ITS SHOULDERS VESTED ALREADY WITH THAT PLANETS RAYS",
                mapType: "SNAKE"
            },
            NEURO: {
                id: 'NEURO',
                stylePrompt: "Cyberpunk first person view, neon green lights, digital matrix rain, glitch art, dark cityscape",
                palette: { text: '#00ff41', bg: '#000500', floorStart: '#001a05', floorEnd: '#000000', map: '#00ff41' },
                text: "THE SKY ABOVE THE PORT WAS THE COLOR OF TELEVISION TUNED TO A DEAD CHANNEL IT WAS NOT LIKE HE EXPECTED THE BODILESS EXULTATION OF CYBERSPACE BUT A GRAY DISCONTINUITY A STATIC FIELD OF BROKEN DATA FRAGMENTS SHARDS OF MEANING FLOATING IN THE VOID CASE SAT IN THE LOFT WATCHING THE SUN RISE OVER THE GEODESICS OF THE PORT THE AIR SMELLED OF CHEAP SOY AND OZONE THE GHOSTS OF THE SPREUL WERE RESTLESS TONIGHT FLICKERING THROUGH THE NEON HAZE OF NIGHT CITY HE REMEMBERED THE MATRIX THE CONSENSUAL HALLUCINATION EXPERIENCED DAILY BY BILLIONS OF LEGITIMATE OPERATORS IN EVERY NATION BY CHILDREN BEING TAUGHT MATHEMATICAL CONCEPTS A GRAPHIC REPRESENTATION OF DATA ABSTRACTED FROM THE BANKS OF EVERY COMPUTER IN THE HUMAN SYSTEM UNTHINKABLE COMPLEXITY LINES OF LIGHT RANGED IN THE NONSPACE OF THE MIND",
                mapType: "ROWS"
            }
        };

        const KEYWORDS = {
            "GOLD": "#FFD700", "SUN": "#FFA500", "FIRE": "#FF4500", "RADIANT": "#FFFFE0",
            "BLOOD": "#8A0303", "WAR": "#B22222", "WRATH": "#FF0000", "FEAR": "#4B0082",
            "OCEAN": "#00BFFF", "SEA": "#1E90FF", "SKY": "#87CEEB", "VOID": "#333333",
            "FOREST": "#228B22", "MATRIX": "#00FF00", "DATA": "#00FF41", "NEON": "#FF00FF"
        };

        const State = {
            world: null, map: [], textStrips: [], textures: [],
            player: { x: 12.5, y: 12.5, dirX: -1, dirY: 0, planeX: 0, planeY: 0.66 },
            keys: { w: false, a: false, s: false, d: false, rotLeft: false, rotRight: false },
            touch: { move: 0, turn: 0 },
            lastTime: 0,
            visibleStrips: new Set(),
            history: [],
            memories: [], 
            lastScannerText: "",
            scannerVisible: true,
            effectInterval: null
        };

        // --- DOM ---
        const canvas = document.getElementById('raycaster');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const depthCanvas = document.getElementById('depth-canvas');
        const dCtx = depthCanvas.getContext('2d', { alpha: false });
        const minimapCanvas = document.getElementById('minimap-canvas');
        const mmCtx = minimapCanvas.getContext('2d');
        const debugPos = document.getElementById('debug-pos');
        const scannerOut = document.getElementById('scanner-output');
        const guideLeft = document.getElementById('guide-left');
        const guideRight = document.getElementById('guide-right');
        const bufferBox = document.getElementById('buffer-history');

        // --- RESIZE ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            depthCanvas.width = window.innerWidth;
            depthCanvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false; 
            updateBeamVisuals();
        }
        window.addEventListener('resize', resize);

        // --- HAPTICS ---
        function pulse(ms = 10) {
            if (navigator.vibrate) navigator.vibrate(ms);
        }

        // --- TTS ---
        function speakBuffer() {
            if (!window.speechSynthesis) return;
            const text = scannerOut.innerText;
            if (!text || text === "..." || text === "NO SIGNAL") return;
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.9;
            utterance.pitch = 0.8;
            window.speechSynthesis.speak(utterance);
        }

        // --- DEPTH CAPTURE ---
        function captureDepthMap() {
            dCtx.fillStyle = "#000";
            dCtx.fillRect(0,0,depthCanvas.width, depthCanvas.height);
            
            const w = depthCanvas.width;
            const h = depthCanvas.height;
            const step = CONFIG.res; 

            for(let x=0; x<w; x+=step) {
                const camX = 2 * x / w - 1;
                const rayDirX = State.player.dirX + State.player.planeX * camX;
                const rayDirY = State.player.dirY + State.player.planeY * camX;
                let mapX = Math.floor(State.player.x), mapY = Math.floor(State.player.y);
                let sideDistX, sideDistY, perpDist;
                let stepX, stepY, hit = 0, side;
                const deltaDistX = (rayDirX === 0) ? 1e30 : Math.abs(1/rayDirX);
                const deltaDistY = (rayDirY === 0) ? 1e30 : Math.abs(1/rayDirY);

                if(rayDirX < 0) { stepX = -1; sideDistX = (State.player.x - mapX) * deltaDistX; }
                else { stepX = 1; sideDistX = (mapX + 1.0 - State.player.x) * deltaDistX; }
                if(rayDirY < 0) { stepY = -1; sideDistY = (State.player.y - mapY) * deltaDistY; }
                else { stepY = 1; sideDistY = (mapY + 1.0 - State.player.y) * deltaDistY; }

                while(hit === 0) {
                    if(sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side=0; }
                    else { sideDistY += deltaDistY; mapY += stepY; side=1; }
                    if(mapX < 0 || mapX >= CONFIG.mapWidth || mapY < 0 || mapY >= CONFIG.mapHeight) { hit=1; perpDist=100; }
                    else if(State.map[mapX][mapY].type > 0) hit=1;
                }

                if(mapX >= 0 && mapX < CONFIG.mapWidth && mapY >= 0 && mapY < CONFIG.mapHeight) {
                    if(side === 0) perpDist = (mapX - State.player.x + (1 - stepX) / 2) / rayDirX;
                    else           perpDist = (mapY - State.player.y + (1 - stepY) / 2) / rayDirY;

                    if(perpDist < 30) {
                        const lineH = Math.floor(h / perpDist);
                        const drawStart = -lineH / 2 + h / 2;
                        
                        let depthVal = Math.max(0, 255 - (perpDist * 12));
                        dCtx.fillStyle = `rgb(${depthVal},${depthVal},${depthVal})`;
                        dCtx.fillRect(x, drawStart, step, lineH);
                    }
                }
            }
            return depthCanvas.toDataURL('image/jpeg', 0.85);
        }

        // --- IMAGE GEN & MEMORY ---
        function getTargetWall() {
            const rayDirX = State.player.dirX;
            const rayDirY = State.player.dirY;
            let mapX = Math.floor(State.player.x), mapY = Math.floor(State.player.y);
            let sideDistX, sideDistY;
            const deltaDistX = (rayDirX === 0) ? 1e30 : Math.abs(1/rayDirX);
            const deltaDistY = (rayDirY === 0) ? 1e30 : Math.abs(1/rayDirY);
            let stepX, stepY, hit = 0;

            if(rayDirX < 0) { stepX = -1; sideDistX = (State.player.x - mapX) * deltaDistX; }
            else { stepX = 1; sideDistX = (mapX + 1.0 - State.player.x) * deltaDistX; }
            if(rayDirY < 0) { stepY = -1; sideDistY = (State.player.y - mapY) * deltaDistY; }
            else { stepY = 1; sideDistY = (mapY + 1.0 - State.player.y) * deltaDistY; }

            for(let i=0; i<40; i++) {
                if(sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; }
                else { sideDistY += deltaDistY; mapY += stepY; }
                if(mapX < 0 || mapX >= CONFIG.mapWidth || mapY < 0 || mapY >= CONFIG.mapHeight) return null;
                if(State.map[mapX][mapY].type > 0) {
                    const dist = Math.sqrt((mapX - State.player.x)**2 + (mapY - State.player.y)**2);
                    return {x: mapX, y: mapY, dist: dist};
                }
            }
            return null;
        }

        function setOpacity(id, val) {
            document.getElementById(id).style.opacity = val / 100;
        }

        function updateBlendMode(mode) {
            document.getElementById('gen-image').style.mixBlendMode = mode;
            document.getElementById('img-depth').style.mixBlendMode = mode;
        }

        // --- MATRIX FX ---
        function runMatrixEffect(promptText) {
            const eCan = document.getElementById('effect-canvas');
            const eCtx = eCan.getContext('2d');
            eCan.width = eCan.offsetWidth;
            eCan.height = eCan.offsetHeight;
            
            // Extract distinct words from the prompt for the rain columns
            const words = promptText.toUpperCase().split(/\s+/).filter(w => w.length > 0);
            if(words.length === 0) return;

            const columns = Math.floor(eCan.width / 14);
            const drops = Array(columns).fill(1);
            // Assign a word to each column index to cycle through
            const columnWords = Array(columns).fill(0).map((_, i) => words[i % words.length]);
            
            // Animation for morphing depth/screenshot during load
            const imgDepth = document.getElementById('img-depth');
            const imgScreen = document.getElementById('img-screenshot');
            let morphTick = 0;

            State.effectInterval = setInterval(() => {
                // Morphing Logic: Pulse between depth and reality
                morphTick += 0.05;
                const blendVal = (Math.sin(morphTick) + 1) / 2; // 0 to 1
                imgDepth.style.opacity = blendVal;
                imgDepth.style.mixBlendMode = 'normal'; // Reset for pure morph
                
                // Matrix Rain
                eCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                eCtx.fillRect(0, 0, eCan.width, eCan.height);
                
                eCtx.fillStyle = State.world.palette.text;
                eCtx.font = 'bold 12px Courier New';
                
                for(let i = 0; i < drops.length; i++) {
                    const word = columnWords[i];
                    // Pick char based on drop height (cycling through word)
                    const charIndex = Math.floor(drops[i]) % word.length;
                    const text = word[charIndex];
                    
                    eCtx.fillText(text, i * 14, drops[i] * 14);
                    
                    if(drops[i] * 14 > eCan.height && Math.random() > 0.975) drops[i] = 0;
                    drops[i]++;
                }
            }, 30);
        }

        function stopMatrixEffect() {
            if(State.effectInterval) clearInterval(State.effectInterval);
            const eCan = document.getElementById('effect-canvas');
            const eCtx = eCan.getContext('2d');
            eCtx.clearRect(0, 0, eCan.width, eCan.height);
            
            // Reset depth opacity so it doesn't get stuck
            document.getElementById('img-depth').style.opacity = 0;
        }

        // --- GENERATION LOGIC ---
        async function generateFromBuffer() {
            const text = scannerOut.innerText;
            if (!text || text === "..." || text === "NO SIGNAL") return;

            const modal = document.getElementById('img-modal');
            const imgScreen = document.getElementById('img-screenshot');
            const imgGen = document.getElementById('gen-image');
            const imgDepth = document.getElementById('img-depth');
            const cap = document.getElementById('img-caption');
            const mixerUI = document.getElementById('mixer-ui');
            const actionBtns = document.getElementById('action-buttons');
            
            const screenShot = canvas.toDataURL('image/jpeg', 0.85);
            const depthMap = captureDepthMap();

            imgScreen.src = screenShot;
            imgDepth.src = depthMap;
            imgGen.style.opacity = 0; 
            imgDepth.style.opacity = 0;
            imgGen.src = ""; 
            mixerUI.style.display = 'none';
            actionBtns.style.display = 'none';
            
            modal.classList.add('active');
            cap.innerText = "ESTABLISHING NEURAL LINK...";
            
            runMatrixEffect(text);

            const apiKey = ""; 
            const style = State.world.stylePrompt;
            const cleanText = text.replace(/[^a-zA-Z0-9 ]/g, '');
            
            const targetWall = getTargetWall();
            let distanceContext = "First-person view";
            if(targetWall) {
                if(targetWall.dist < 2) distanceContext = "Extreme close-up macro texture view";
                else if(targetWall.dist < 6) distanceContext = "Intimate close range view";
                else distanceContext = "Wide cinematic shot, distant view";
            }

            let moodColor = "";
            for (const [key, color] of Object.entries(KEYWORDS)) {
                if (cleanText.includes(key)) {
                    moodColor = `dominated by glowing ${key} light and atmosphere`;
                    break;
                }
            }

            const fullPrompt = `${distanceContext} of a 3D scene described as: "${cleanText}". Art style: ${style}. ${moodColor}. Highly detailed, cinematic lighting, 8k resolution. IMPORTANT: Do not render any text, words, or letters in the image. Just the visual scene and environment.`;

            let memoryData = null;
            if(targetWall) {
                State.map[targetWall.x][targetWall.y].hasMemory = true;
                memoryData = {
                    id: crypto.randomUUID(),
                    timestamp: new Date().toISOString(),
                    world_id: State.world.id,
                    prompt_text: text,
                    full_prompt: fullPrompt,
                    pose: {
                        x: State.player.x, y: State.player.y, z: 0.5,
                        dir: { x: State.player.dirX, y: State.player.dirY },
                        plane: { x: State.player.planeX, y: State.player.planeY }
                    },
                    intrinsics: {
                        fov_approx: CONFIG.fov,
                        resolution: [canvas.width, canvas.height]
                    },
                    target: {
                        wall_x: targetWall.x, wall_y: targetWall.y, distance: targetWall.dist
                    },
                    images: {
                        screenshot_base64: screenShot,
                        depth_base64: depthMap,
                        vision_base64: null
                    }
                };
                State.memories.push(memoryData);
                pulse(100); 
            }

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        instances: [{ prompt: fullPrompt }],
                        parameters: { sampleCount: 1 }
                    })
                });
                const data = await response.json();
                stopMatrixEffect();
                
                if (data.predictions && data.predictions[0]) {
                    const b64 = `data:image/png;base64,${data.predictions[0].bytesBase64Encoded}`;
                    imgGen.src = b64;
                    if(memoryData) memoryData.images.vision_base64 = b64;

                    cap.innerText = `"${text}"`;
                    mixerUI.style.display = 'flex';
                    actionBtns.style.display = 'flex';
                    
                    // Reset mixers
                    document.getElementById('slider-vision').value = 100;
                    document.getElementById('slider-depth').value = 0;
                    document.getElementById('blend-mode-select').value = 'normal';
                    updateBlendMode('normal');
                    imgGen.style.opacity = 1;
                    imgDepth.style.opacity = 0;

                } else {
                    cap.innerText = "ERROR: NEURAL LINK FAILED.";
                }
            } catch (e) {
                stopMatrixEffect();
                cap.innerText = "ERROR: CONNECTION LOST.";
            }
        }

        function closeImgModal() {
            document.getElementById('img-modal').classList.remove('active');
            stopMatrixEffect();
        }

        // --- IO (Refined) ---
        function downloadImage(id, name) {
            const img = document.getElementById(id);
            if(!img || !img.src) {
                alert("Image not ready.");
                return;
            }
            const a = document.createElement('a');
            a.href = img.src;
            a.download = `semantic_${name}_${Date.now()}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        async function copyImage(id) {
            const img = document.getElementById(id);
            if(!img || !img.src) {
                alert("Image not ready.");
                return;
            }
            try {
                const res = await fetch(img.src);
                const blob = await res.blob();
                const item = new ClipboardItem({[blob.type]: blob});
                await navigator.clipboard.write([item]);
                alert("IMAGE COPIED");
            } catch(e) {
                console.error(e);
                alert("COPY FAILED (Check Browser Permissions)");
            }
        }

        // DOWNLOAD COMPOSITE
        function downloadComposite() {
            const imgScreen = document.getElementById('img-screenshot');
            const imgGen = document.getElementById('gen-image');
            const imgDepth = document.getElementById('img-depth');
            
            if(!imgGen.src || imgGen.src.length < 100) {
                alert("Vision not generated yet.");
                return;
            }

            // Create a temp canvas to stitch them
            const c = document.createElement('canvas');
            const w = imgScreen.naturalWidth || 800;
            const h = imgScreen.naturalHeight || 600;
            
            // Triptych layout: Reality | Vision | Depth
            c.width = w * 3;
            c.height = h;
            const cx = c.getContext('2d');
            
            // Draw Reality
            cx.drawImage(imgScreen, 0, 0, w, h);
            // Draw Vision
            cx.drawImage(imgGen, w, 0, w, h);
            // Draw Depth
            cx.drawImage(imgDepth, w*2, 0, w, h);
            
            // Add Labels
            cx.fillStyle = "#fff";
            cx.font = "bold 20px monospace";
            cx.fillText("REALITY", 20, 30);
            cx.fillText("VISION", w + 20, 30);
            cx.fillText("GEOMETRY", w*2 + 20, 30);

            // Download
            const a = document.createElement('a');
            a.href = c.toDataURL('image/jpeg', 0.9);
            a.download = `semantic_triad_${Date.now()}.jpg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function exportMemories() {
            if(State.memories.length === 0) {
                alert("NO MEMORIES COLLECTED YET.");
                return;
            }
            
            const bundle = {
                version: "1.0",
                exported_at: new Date().toISOString(),
                world_info: {
                    id: State.world.id,
                    map_dims: [CONFIG.mapWidth, CONFIG.mapHeight],
                    tile_size: 1.0
                },
                frames: State.memories
            };

            const json = JSON.stringify(bundle, null, 2);
            const blob = new Blob([json], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `semantic_world_${State.world.id}_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- INPUT HANDLING ---
        function handleKey(e, down) {
            const k = e.key.toLowerCase();
            if(k==='w' || k==='arrowup') State.keys.w = down;
            if(k==='s' || k==='arrowdown') State.keys.s = down;
            if(k==='a') State.keys.a = down;
            if(k==='d') State.keys.d = down;
            if(k==='arrowleft') State.keys.rotLeft = down;
            if(k==='arrowright') State.keys.rotRight = down;
            if(down && k==='h') toggleCinematic();
            if(down && k===' ') { e.preventDefault(); State.scannerVisible=true; document.body.classList.remove('hide-scanner'); }
        }
        window.addEventListener('keydown', e => handleKey(e, true));
        window.addEventListener('keyup', e => handleKey(e, false));

        const stickMove = document.getElementById('stick-move');
        const stickLook = document.getElementById('stick-look');

        const handleTouch = (e, axis) => {
            e.preventDefault();
            const rect = e.currentTarget.getBoundingClientRect();
            const t = e.targetTouches[0];
            if(!t) { State.touch[axis] = 0; return; }
            if(axis === 'move') {
                const val = (t.clientY - (rect.top + rect.height/2)) / (rect.height/2);
                State.touch.move = -Math.max(-1, Math.min(1, val));
            } else {
                const val = (t.clientX - (rect.left + rect.width/2)) / (rect.width/2);
                State.touch.turn = Math.max(-1, Math.min(1, val));
            }
        };
        const resetTouch = (e, axis) => { e.preventDefault(); State.touch[axis] = 0; };

        stickMove.addEventListener('touchstart', e => handleTouch(e, 'move'), {passive:false});
        stickMove.addEventListener('touchmove', e => handleTouch(e, 'move'), {passive:false});
        stickMove.addEventListener('touchend', e => resetTouch(e, 'move'));
        stickLook.addEventListener('touchstart', e => handleTouch(e, 'turn'), {passive:false});
        stickLook.addEventListener('touchmove', e => handleTouch(e, 'turn'), {passive:false});
        stickLook.addEventListener('touchend', e => resetTouch(e, 'turn'));

        // --- UI LOGIC ---
        function toggleTUI() { document.getElementById('tui-overlay').classList.toggle('active'); }
        function toggleCinematic() { 
            document.body.classList.toggle('cinematic'); 
            document.getElementById('tui-overlay').classList.remove('active');
        }
        function toggleScannerUI() {
            State.scannerVisible = !State.scannerVisible;
            document.body.classList.toggle('hide-scanner', !State.scannerVisible);
        }
        function updateBeam(val) {
            CONFIG.scannerWidth = parseInt(val);
            document.getElementById('val-beam').innerText = val;
            updateBeamVisuals();
        }
        function updateBeamVisuals() {
            const cx = window.innerWidth/2;
            const w = CONFIG.scannerWidth/2;
            guideLeft.style.left = (cx - w)+'px';
            guideRight.style.left = (cx + w)+'px';
        }
        function copyBuffer() {
            navigator.clipboard.writeText(State.history.join('\n'));
            alert('Copied to clipboard');
        }
        function clearBuffer() {
            State.history = [];
            bufferBox.innerText = "// Buffer cleared.";
        }
        function addToBuffer(txt) {
            if(!txt || txt.length < 3) return;
            if(State.history.length > 50) State.history.shift();
            State.history.push(txt);
            const d = document.createElement('div');
            d.innerText = `> ${txt}`;
            d.style.borderBottom = "1px solid #333";
            d.style.marginBottom = "5px";
            if(bufferBox.innerText.startsWith("//")) bufferBox.innerHTML = "";
            bufferBox.appendChild(d);
            bufferBox.scrollTop = bufferBox.scrollHeight;
        }

        // --- MAP & TEXTURE ---
        function processTextStrips(txt) {
            const clean = txt.toUpperCase().replace(/\s+/g, ' ');
            const strips = [];
            for(let i=0; i<clean.length; i+=CONFIG.charsPerStrip) {
                let s = clean.substring(i, i+CONFIG.charsPerStrip);
                while(s.length < CONFIG.charsPerStrip) s += " ";
                strips.push(s);
            }
            return strips;
        }

        function generateTextures(strips, defaultColor) {
            State.textures = [];
            const size = CONFIG.charResolution;
            const h = size * CONFIG.charsPerStrip;
            
            strips.forEach(s => {
                const c = document.createElement('canvas');
                c.width = size; c.height = h;
                const ctx = c.getContext('2d');
                
                let stripColor = defaultColor;
                for (const [key, color] of Object.entries(KEYWORDS)) {
                    if (s.includes(key)) {
                        stripColor = color;
                        break;
                    }
                }

                ctx.fillStyle = stripColor;
                ctx.font = `900 ${size*0.8}px 'Courier New'`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                
                for(let i=0; i<s.length; i++) {
                    if(s[i] !== ' ') {
                        const y = i*size + size/2;
                        if(stripColor !== defaultColor) {
                            ctx.shadowBlur = 10; ctx.shadowColor = stripColor;
                        }
                        ctx.fillText(s[i], size/2, y);
                        ctx.shadowBlur = 0;
                    }
                }
                State.textures.push(c);
            });
        }

        function generateMap(type) {
            const s = CONFIG.mapWidth;
            const map = [];
            let stripIdx = 0;
            const total = State.textStrips.length;
            for(let x=0; x<s; x++) {
                map[x] = [];
                for(let y=0; y<s; y++) map[x][y] = { type: 0, idx: -1, hasMemory: false };
            }
            
            const setWall = (x,y) => { if(x>=0 && x<s && y>=0 && y<s) map[x][y].type = 1; };
            if(type === 'RINGS') {
                const cx=s/2, cy=s/2;
                for(let x=0; x<s; x++) for(let y=0; y<s; y++) {
                    const d = Math.sqrt((x-cx)**2 + (y-cy)**2);
                    if((Math.abs(d-5)<0.8 || Math.abs(d-9)<0.8) && (x!==12 && y!==12)) setWall(x,y);
                }
            } else if(type === 'SNAKE') {
                let x=2,y=2,dx=1,dy=0,steps=0;
                while(steps<150) {
                    setWall(x,y);
                    if(Math.random()>0.8) { if(dx!==0){dx=0;dy=1;}else{dx=1;dy=0;} }
                    x+=dx; y+=dy;
                    if(x>=s-2) {x=2;y+=2;} if(y>=s-2) {y=2;x+=2;}
                    steps++;
                }
            } else {
                for(let x=4; x<s-4; x+=4) for(let y=3; y<s-3; y++) setWall(x,y);
            }

            for(let x=0; x<s; x++) for(let y=0; y<s; y++) {
                if(map[x][y].type === 1) {
                    map[x][y].idx = stripIdx;
                    stripIdx = (stripIdx + CONFIG.strandsPerBlock) % total;
                }
            }
            return map;
        }

        function loadWorld(key) {
            document.querySelectorAll('.btn-source').forEach(b => b.classList.remove('active'));
            const btn = document.querySelector(`.btn-source[onclick="loadWorld('${key}')"]`);
            if(btn) btn.classList.add('active');

            const d = WORLDS[key];
            State.world = d;
            document.documentElement.style.setProperty('--ui-text', d.palette.text);
            document.documentElement.style.setProperty('--ui-dim', d.palette.text + '44');
            
            clearBuffer();
            State.memories = []; // Reset memories for new world
            State.textStrips = processTextStrips(d.text);
            generateTextures(State.textStrips, d.palette.text);
            State.map = generateMap(d.mapType);
            
            State.player.x = 12.5; State.player.y = 12.5;
            State.player.dirX = -1; State.player.dirY = 0;
            State.player.planeX = 0; State.player.planeY = 0.66;
        }

        // --- RENDER LOOP ---
        function update(dt) {
            const ms = CONFIG.speed.move * dt;
            const rs = CONFIG.speed.rot * dt;
            
            let fwd = 0; if(State.keys.w) fwd += 1; if(State.keys.s) fwd -= 1; fwd += State.touch.move;
            let trn = 0; if(State.keys.rotRight || State.keys.d) trn += 1; if(State.keys.rotLeft || State.keys.a) trn -= 1; trn += State.touch.turn;

            if(trn !== 0) {
                const oldDir = State.player.dirX;
                const oldPlane = State.player.planeX;
                const c = Math.cos(trn * rs), s = Math.sin(trn * rs);
                State.player.dirX = State.player.dirX * c - State.player.dirY * s;
                State.player.dirY = oldDir * s + State.player.dirY * c;
                State.player.planeX = State.player.planeX * c - State.player.planeY * s;
                State.player.planeY = oldPlane * s + State.player.planeY * c;
            }

            if(fwd !== 0 || str !== 0) {
                const dx = State.player.dirX * fwd + (-State.player.dirY) * str;
                const dy = State.player.dirY * fwd + (State.player.dirX) * str;
                const nx = State.player.x + dx * ms;
                const ny = State.player.y + dy * ms;
                
                if(nx >= 0 && nx < CONFIG.mapWidth && ny >= 0 && ny < CONFIG.mapHeight) {
                    if(State.map[Math.floor(nx)][Math.floor(State.player.y)].type === 0) State.player.x = nx;
                    else pulse(15); 
                    
                    if(State.map[Math.floor(State.player.x)][Math.floor(ny)].type === 0) State.player.y = ny;
                    else pulse(15);
                }
            }
            debugPos.innerText = `${State.player.x.toFixed(1)}, ${State.player.y.toFixed(1)}`;
        }

        function drawMinimap() {
            const s = CONFIG.mapWidth;
            const sz = minimapCanvas.width / s;
            mmCtx.fillStyle = '#000';
            mmCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Walls
            for(let x=0; x<s; x++) for(let y=0; y<s; y++) {
                const cell = State.map[x][y];
                if(cell.type === 1) {
                    // Highlight memory locations on map
                    mmCtx.fillStyle = cell.hasMemory ? '#00ffff' : State.world.palette.map;
                    mmCtx.fillRect(x*sz, y*sz, sz, sz);
                }
            }
            
            // Player
            const px = State.player.x * sz;
            const py = State.player.y * sz;
            mmCtx.fillStyle = '#fff';
            mmCtx.beginPath(); mmCtx.arc(px, py, 2, 0, Math.PI*2); mmCtx.fill();
            
            // Visualize Rays (FOV)
            mmCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            mmCtx.lineWidth = 0.5;
            mmCtx.beginPath();
            mmCtx.moveTo(px, py);
            const leftDirX = State.player.dirX + State.player.planeX * -1;
            const leftDirY = State.player.dirY + State.player.planeY * -1;
            mmCtx.lineTo(px + leftDirX * 12, py + leftDirY * 12);
            mmCtx.moveTo(px, py);
            const rightDirX = State.player.dirX + State.player.planeX * 1;
            const rightDirY = State.player.dirY + State.player.planeY * 1;
            mmCtx.lineTo(px + rightDirX * 12, py + rightDirY * 12);
            mmCtx.stroke();
        }

        function draw() {
            ctx.fillStyle = State.world.palette.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const grad = ctx.createLinearGradient(0, canvas.height/2, 0, canvas.height);
            grad.addColorStop(0, State.world.palette.floorStart);
            grad.addColorStop(1, State.world.palette.floorEnd);
            ctx.fillStyle = grad;
            ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);

            const w = canvas.width, h = canvas.height;
            const cx = w/2;
            const beamHalf = CONFIG.scannerWidth/2;
            State.visibleStrips.clear();

            for(let x=0; x<w; x+=CONFIG.res) {
                const camX = 2 * x / w - 1;
                const rayDirX = State.player.dirX + State.player.planeX * camX;
                const rayDirY = State.player.dirY + State.player.planeY * camX;
                
                let mapX = Math.floor(State.player.x), mapY = Math.floor(State.player.y);
                let sideDistX, sideDistY, perpDist;
                let stepX, stepY, hit = 0, side;
                
                const deltaDistX = (rayDirX === 0) ? 1e30 : Math.abs(1/rayDirX);
                const deltaDistY = (rayDirY === 0) ? 1e30 : Math.abs(1/rayDirY);

                if(rayDirX < 0) { stepX = -1; sideDistX = (State.player.x - mapX) * deltaDistX; }
                else { stepX = 1; sideDistX = (mapX + 1.0 - State.player.x) * deltaDistX; }
                if(rayDirY < 0) { stepY = -1; sideDistY = (State.player.y - mapY) * deltaDistY; }
                else { stepY = 1; sideDistY = (mapY + 1.0 - State.player.y) * deltaDistY; }

                while(hit === 0) {
                    if(sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                    else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                    
                    if(mapX < 0 || mapX >= CONFIG.mapWidth || mapY < 0 || mapY >= CONFIG.mapHeight) {
                        hit = 1; perpDist = 100; 
                    } else if(State.map[mapX][mapY].type > 0) {
                        hit = 1;
                    }
                }

                if(mapX >= 0 && mapX < CONFIG.mapWidth && mapY >= 0 && mapY < CONFIG.mapHeight) {
                    if(side === 0) perpDist = (mapX - State.player.x + (1 - stepX) / 2) / rayDirX;
                    else           perpDist = (mapY - State.player.y + (1 - stepY) / 2) / rayDirY;

                    if(perpDist < 30) {
                        const lineH = Math.floor(h / perpDist);
                        const drawStart = -lineH / 2 + h / 2;
                        
                        let wallX;
                        if(side === 0) wallX = State.player.y + perpDist * rayDirY;
                        else           wallX = State.player.x + perpDist * rayDirX;
                        wallX -= Math.floor(wallX);

                        const tiledX = wallX * CONFIG.strandsPerBlock;
                        const strandOffset = Math.floor(tiledX);
                        const texU = tiledX - strandOffset;

                        const cell = State.map[mapX][mapY];
                        if(cell.type > 0 && cell.idx !== -1) {
                            const texIdx = (cell.idx + strandOffset) % State.textures.length;
                            const texture = State.textures[texIdx];
                            
                            let isSampled = false;
                            if(State.scannerVisible && Math.abs(x - cx) < beamHalf) {
                                State.visibleStrips.add(texIdx);
                                isSampled = true;
                            }

                            const texX = Math.floor(texU * CONFIG.charResolution);
                            let bright = 1.0 / (perpDist * 0.4);
                            if(side === 1) bright *= 0.7;
                            
                            if(isSampled) { 
                                bright = Math.min(1.5, bright*2); 
                                ctx.filter = 'brightness(1.5)'; 
                            } else if(cell.hasMemory) {
                                bright = Math.min(1.2, bright * 1.2);
                                ctx.filter = 'hue-rotate(180deg) brightness(1.2) contrast(1.2)'; 
                            } else {
                                if(bright > 1) bright = 1; 
                                ctx.filter = 'none'; 
                            }

                            ctx.globalAlpha = bright;
                            ctx.drawImage(texture, texX, 0, 1, texture.height, x, drawStart, CONFIG.res, lineH);
                            ctx.globalAlpha = 1.0;
                            ctx.filter = 'none';
                        }
                    }
                }
            }

            if(State.scannerVisible) {
                if(State.visibleStrips.size > 0) {
                    const idxs = Array.from(State.visibleStrips).sort((a,b)=>a-b);
                    
                    // REASSEMBLE TEXT
                    let rawText = "";
                    idxs.forEach(i => rawText += State.textStrips[i]);
                    // Collapse multiple spaces into one for display
                    let txt = rawText.replace(/\s+/g, ' ').trim();
                    
                    if(txt !== State.lastScannerText) {
                        scannerOut.innerText = txt;
                        scannerOut.style.borderColor = State.world.palette.text;
                        State.lastScannerText = txt;
                        if(txt.length > 5) {
                            addToBuffer(txt);
                            pulse(5); // Tiny haptic tick
                        }
                    }
                } else if(State.lastScannerText !== "...") {
                    scannerOut.innerText = "...";
                    scannerOut.style.borderColor = "#333";
                    State.lastScannerText = "...";
                }
            }
            drawMinimap();
        }

        function gameLoop(time) {
            const dt = (time - State.lastTime) / 1000;
            State.lastTime = time;
            update(dt);
            draw();
            requestAnimationFrame(gameLoop);
        }

        resize();
        loadWorld('ILIAD');
        setTimeout(() => {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(()=> document.getElementById('loader').style.display='none', 500);
            requestAnimationFrame(gameLoop);
        }, 1000);

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KEATS_URN_24 // Operative Cartography</title>
    <style>
        :root {
            --bg-color: #0a0a0c;
            --panel-bg: #141418;
            --text-main: #c0c0c0;
            --text-dim: #606070;
            --accent: #d4a04d; /* Amber for Seal */
            --highlight: #ffffff;
            --grid-gap: 2px;
            
            /* Zone Colors */
            --c-rim: #4a5568;
            --c-frieze: #3182ce;
            --c-belly: #2d3748;
            --c-absence: #1a202c; /* Very dark */
            --c-seal: #d69e2e;
            --c-approach: #805ad5;
        }

        * { box-sizing: border-box; }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* HEADER */
        header {
            padding: 1rem;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--panel-bg);
            flex-shrink: 0;
        }

        h1 { margin: 0; font-size: 1rem; letter-spacing: 0.05em; text-transform: uppercase; color: var(--accent); }
        .meta { font-size: 0.7rem; color: var(--text-dim); }

        /* MAIN LAYOUT */
        main {
            flex: 1;
            display: flex;
            flex-direction: row;
            overflow: hidden;
        }

        /* LEFT: CARTOGRAPHY (GRID) */
        .cartography-panel {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-right: 1px solid #333;
            position: relative;
        }

        .readout {
            width: 100%;
            height: 3rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: #000;
            border: 1px solid #333;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: var(--accent);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .readout.active { opacity: 1; }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(24, 1fr);
            grid-template-rows: repeat(24, 1fr);
            gap: 1px;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1/1;
        }

        .cell {
            background-color: var(--c-belly);
            cursor: crosshair;
            transition: all 0.1s;
            position: relative;
        }

        .cell:hover {
            z-index: 10;
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
            border: 1px solid white;
        }

        /* Zone Classes */
        .z-RIM_TOP, .z-RIM_BOTTOM { background-color: var(--c-rim); opacity: 0.6; }
        .z-UPPER_FRIEZE, .z-LOWER_FRIEZE { background-color: var(--c-frieze); opacity: 0.7; }
        .z-BELLY { background-color: var(--c-belly); opacity: 0.5; }
        .z-ABSENCE_FIELD { background-color: var(--c-absence); border: 1px dashed #333; }
        .z-SEAL { background-color: var(--c-seal); opacity: 1; box-shadow: 0 0 5px var(--c-seal); }
        .z-CENTER_APPROACH { background-color: var(--c-approach); opacity: 0.6; }

        /* Interaction States */
        .cell.highlight {
            background-color: var(--highlight) !important;
            opacity: 1 !important;
        }

        .cell.dimmed {
            opacity: 0.1;
        }

        /* RIGHT: CODEX (TEXT) */
        .codex-panel {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: var(--panel-bg);
            border-left: 1px solid #333;
        }

        .line-entry {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            border-left: 2px solid transparent;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.2s;
            display: flex;
            gap: 10px;
        }

        .line-entry:hover {
            background: #2a2a30;
        }

        .line-entry.active {
            background: #2a2a30;
            border-left-color: var(--accent);
            color: white;
        }

        .line-meta {
            min-width: 30px;
            color: var(--text-dim);
            font-size: 0.65rem;
            text-align: right;
            display: flex;
            flex-direction: column;
        }

        .line-tag {
            font-size: 0.6rem;
            text-transform: uppercase;
            opacity: 0.7;
            margin-top: 2px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            main { flex-direction: column; }
            .cartography-panel { flex: none; height: 50vh; border-right: none; border-bottom: 1px solid #333; }
            .codex-panel { flex: 1; border-left: none; }
            h1 { font-size: 0.8rem; }
        }
    </style>
</head>
<body>

<header>
    <div>
        <h1>Keats_Urn_24</h1>
        <div class="meta">Operative Ekphrasis // Resolution: 24x24</div>
    </div>
    <div style="text-align: right;" class="meta">
        <span style="color:var(--c-rim)">RIM</span> | 
        <span style="color:var(--c-frieze)">FRIEZE</span> | 
        <span style="color:var(--c-seal)">SEAL</span> | 
        <span style="color:#555">VOID</span>
    </div>
</header>

<main>
    <div class="cartography-panel">
        <div class="readout" id="readout">HOVER GRID TO DECODE SURFACE TEXT</div>
        <div class="grid-container" id="grid">
            <!-- Grid generated by JS -->
        </div>
    </div>

    <div class="codex-panel" id="codex">
        <!-- Lines generated by JS -->
    </div>
</main>

<script>
    // --- DATA: THE POEM & ARCHITECTURE ---

    const RAW_POEM = `Thou still unravish'd bride of quietness,
Thou foster-child of silence and slow time,
Sylvan historian, who canst thus express
A flowery tale more sweetly than our rhyme:
What leaf-fring'd legend haunts about thy shape
Of deities or mortals, or of both,
In Tempe or the dales of Arcady?
What men or gods are these? What maidens loth?
What mad pursuit? What struggle to escape?
What pipes and timbrels? What wild ecstasy?
Heard melodies are sweet, but those unheard
Are sweeter; therefore, ye soft pipes, play on;
Not to the sensual ear, but, more endear'd,
Pipe to the spirit ditties of no tone:
Fair youth, beneath the trees, thou canst not leave
Thy song, nor ever can those trees be bare;
Bold Lover, never, never canst thou kiss,
Though winning near the goal yet, do not grieve;
She cannot fade, though thou hast not thy bliss,
For ever wilt thou love, and she be fair!
Ah, happy, happy boughs! that cannot shed
Your leaves, nor ever bid the Spring adieu;
And, happy melodist, unwearied,
For ever piping songs for ever new;
More happy love! more happy, happy love!
For ever warm and still to be enjoy'd,
For ever panting, and for ever young;
All breathing human passion far above,
That leaves a heart high-sorrowful and cloy'd,
A burning forehead, and a parching tongue.
Who are these coming to the sacrifice?
To what green altar, O mysterious priest,
Lead'st thou that heifer lowing at the skies,
And all her silken flanks with garlands drest?
What little town by river or sea shore,
Or mountain-built with peaceful citadel,
Is emptied of this folk, this pious morn?
And, little town, thy streets for evermore
Will silent be; and not a soul to tell
Why thou art desolate, can e'er return.
O Attic shape! Fair attitude! with brede
Of marble men and maidens overwrought,
With forest branches and the trodden weed;
Thou, silent form, dost tease us out of thought
As doth eternity: Cold Pastoral!
When old age shall this generation waste,
Thou shalt remain, in midst of other woe
Than ours, a friend to man, to whom thou say'st,
"Beauty is truth, truth beauty,â€”that is all
Ye know on earth, and all ye need to know."`.split('\n');

    // MAPPING LOGIC
    const ALLOCATION = {
        "RIM_TOP": [0,1,2,3],
        "UPPER_FRIEZE": [4,5,6,7,8,9],
        "BELLY": [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29],
        "LOWER_FRIEZE": [30,31,32,33],
        "ABSENCE_FIELD": [34,35,36,37,38,39],
        "RIM_BOTTOM": [40,41,42,45,46],
        "CENTER_APPROACH": [43,44,47],
        "SEAL": [48,49]
    };

    // Construct Line Objects
    const LINES = RAW_POEM.map((text, i) => {
        let zone = "BELLY";
        for (const [z, indices] of Object.entries(ALLOCATION)) {
            if (indices.includes(i)) zone = z;
        }
        return {
            id: `K-${String(i+1).padStart(2,'0')}`,
            index: i,
            text: text,
            zone: zone
        };
    });

    // --- OPERATIVE CARTOGRAPHY LOGIC ---

    const GRID_SIZE = 24;
    const gridData = []; // [y][x]

    // 1. Initialize Grid
    for (let y = 0; y < GRID_SIZE; y++) {
        const row = [];
        for (let x = 0; x < GRID_SIZE; x++) {
            row.push({ x, y, zone: null, lineIndex: null });
        }
        gridData.push(row);
    }

    // 2. Define Geometric Zones (The "World Model")
    function getZoneForCoord(x, y) {
        // Seal Center
        if (x >= 11 && x <= 13 && y >= 11 && y <= 13) return "SEAL";
        
        // Center Approach (Vertical Corridor)
        if (x >= 10 && x <= 14 && y > 13 && y < 21) return "CENTER_APPROACH";

        // Absence Field (The Empty Town) - Southeast Quadrant
        if (x >= 15 && x <= 22 && y >= 14 && y <= 19) return "ABSENCE_FIELD";

        // Horizontal Bands
        if (y <= 2) return "RIM_TOP";
        if (y >= 6 && y <= 9) return "UPPER_FRIEZE";
        if (y >= 14 && y <= 17) return "LOWER_FRIEZE"; // Overlaps with Absence/Approach
        if (y >= 21) return "RIM_BOTTOM";
        
        return "BELLY";
    }

    // 3. Apply Geometry to Grid
    for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
            let z = getZoneForCoord(x, y);
            // Fix overlaps: Absence Field overrides Lower Frieze in that rect
            if (z === "LOWER_FRIEZE" && getZoneForCoord(x,y) === "ABSENCE_FIELD") {
                z = "ABSENCE_FIELD"; 
            }
            gridData[y][x].zone = z;
        }
    }

    // 4. Flood Fill Text into Zones
    // We walk through the grid, find cells of Zone Z, and fill them with lines assigned to Zone Z.
    const cellsByZone = {};
    
    // Collect coordinates for each zone
    for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
            const z = gridData[y][x].zone;
            if (!cellsByZone[z]) cellsByZone[z] = [];
            cellsByZone[z].push({x, y});
        }
    }

    // Distribute lines
    for (const [zoneName, indices] of Object.entries(ALLOCATION)) {
        const targetCells = cellsByZone[zoneName] || [];
        const linesToFit = indices;
        
        if (targetCells.length === 0) continue;

        // Simple spatial distribution: Divide cells evenly among lines
        const cellsPerLine = Math.floor(targetCells.length / linesToFit.length);
        
        let cellCursor = 0;
        linesToFit.forEach((lineIdx, i) => {
            // Determine how many cells this line gets
            // The last line gets the remainder to ensure coverage
            const count = (i === linesToFit.length - 1) 
                ? targetCells.length - cellCursor 
                : cellsPerLine;

            for (let c = 0; c < count; c++) {
                if (cellCursor < targetCells.length) {
                    const coord = targetCells[cellCursor];
                    gridData[coord.y][coord.x].lineIndex = lineIdx;
                    cellCursor++;
                }
            }
        });
    }

    // --- RENDERING ---

    const gridEl = document.getElementById('grid');
    const codexEl = document.getElementById('codex');
    const readoutEl = document.getElementById('readout');

    // Render Grid
    gridData.forEach(row => {
        row.forEach(cell => {
            const div = document.createElement('div');
            div.className = `cell z-${cell.zone}`;
            div.dataset.x = cell.x;
            div.dataset.y = cell.y;
            div.dataset.line = cell.lineIndex;
            
            // Interaction
            div.addEventListener('mouseenter', () => highlightLine(cell.lineIndex));
            div.addEventListener('click', () => highlightLine(cell.lineIndex, true));
            
            gridEl.appendChild(div);
        });
    });

    // Render Codex
    LINES.forEach(line => {
        const div = document.createElement('div');
        div.className = 'line-entry';
        div.id = `line-${line.index}`;
        div.dataset.index = line.index;
        
        div.innerHTML = `
            <div class="line-meta">
                <span>${line.id}</span>
                <span class="line-tag" style="color:var(--c-${line.zone.toLowerCase().split('_')[0]})">${line.zone.replace('_',' ')}</span>
            </div>
            <div class="line-text">${line.text}</div>
        `;

        div.addEventListener('mouseenter', () => highlightGrid(line.index));
        div.addEventListener('click', () => highlightGrid(line.index));
        codexEl.appendChild(div);
    });

    // --- INTERACTION LOGIC ---

    function highlightLine(lineIndex, scroll = false) {
        if (lineIndex === null || lineIndex === undefined) return;

        // Reset
        document.querySelectorAll('.line-entry').forEach(el => el.classList.remove('active'));
        
        // Active
        const lineEl = document.getElementById(`line-${lineIndex}`);
        if (lineEl) {
            lineEl.classList.add('active');
            if (scroll) {
                lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            // Update Readout
            const lineData = LINES[lineIndex];
            readoutEl.textContent = `[${lineData.id}] ${lineData.text.substring(0, 40)}...`;
            readoutEl.classList.add('active');
            readoutEl.style.color = getComputedStyle(document.documentElement).getPropertyValue(`--c-${lineData.zone.toLowerCase().split('_')[0]}`) || '#fff';
        }

        highlightGrid(lineIndex);
    }

    function highlightGrid(lineIndex) {
        // Dim all
        const cells = document.querySelectorAll('.cell');
        
        // If nothing selected, just clear styles
        if (lineIndex === null) {
            cells.forEach(c => {
                c.classList.remove('highlight');
                c.classList.remove('dimmed');
            });
            return;
        }

        cells.forEach(c => {
            const cellLine = parseInt(c.dataset.line);
            if (cellLine === lineIndex) {
                c.classList.add('highlight');
                c.classList.remove('dimmed');
            } else {
                c.classList.remove('highlight');
                c.classList.add('dimmed');
            }
        });
    }

    // Reset on leaving container
    const mainEl = document.querySelector('main');
    mainEl.addEventListener('mouseleave', () => {
        document.querySelectorAll('.cell').forEach(c => {
            c.classList.remove('highlight');
            c.classList.remove('dimmed');
        });
        document.querySelectorAll('.line-entry').forEach(el => el.classList.remove('active'));
        readoutEl.classList.remove('active');
    });

</script>

</body>
</html>